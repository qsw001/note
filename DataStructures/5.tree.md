# 树

## 1.1 树的基本概念

### 1.1.1 树是什么

树：树是一种分层的、非线性数据结构，由若干节点和节点之间的父子关系组成。

树的特点：每个节点有0个或多个子节点，有且只有一个根节点，每个节点恰有一个父节点。

### 1.1.2 树的基本术语与性质

- **节点**(node)：存储数据的单元。
- **根**(root)：没有父节点的节点。
- **叶子**(leaf)：没有子节点的节点。
- **度**(degree)：节点的子节点数位该节点的度。树的度为所有节点中度最大的那个度数。
- **深度**(depth)：该节点到根节点的边数为他的深度，树的深度指的是所有节点到根节点的最大深度。

## 1.2 二叉树

### 1.2.1 二叉树的基本概念

二叉树：二叉树是一种特殊的树，每个节点最多只有两个子节点，通常被称为左子树和右子树。

### 1.2.2 二叉树的存储结构

```
typedef struct TreeNode {
    int data;
    struct TreeNode* leftNode;
    struct TreeNode* rightNode;
} TreeNode;  
```

### 1.2.3 二叉树的基本操作 

- 建立：创建节点，构造整棵树。
- 访问：遍历。
- 查找：按值查找节点。
- 计算：求节点数，叶子树，深度。
- 修改：插入节点，删除节点。
- 销毁：删除整颗树。

#### 1.2.3.1 建立二叉树

要想更容易的理解建立二叉树，我们最好了解一下二叉树的递归定义，即**每一个二叉树是一个有限节点的集合，它或者是空集，或者是由一个根节点和两个互不相交的二叉树组成**。

思想，由树的递归定义决定，如果根节点存在，那么左右节点都可以看作一颗新的树。
```
    TreeNode* createTree() {
        char ch;
        scanf(" %c", &ch);//%c前加空格，为跳过空白字符串机制(空白字符串：为换行，空格，等字符).
        if (ch == '#') {//"#"为字符串常量，后面还有一个\0，'#'为字符常量。
            return NULL;
        }
        TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
        node->data = ch;
        node->leftNode = createTree();
        node->rightNode = createTree();
        return node;
    }
```

#### 1.2.3.2 二叉树的遍历

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

其中，前序、中序、后序的顺序指的是根所在的位置，使用递归的思想，而层序遍历则通过队列实现。
```
//前序遍历
void preorder(TreeNode* node) {
	if (node == NULL)	return;
	printf("%c", node->data);
	preorder(node->leftNode);
	preorder(node->rightNode);
}
```
```
//中序遍历
void inorder(TreeNode* node) {
	if (node == NULL)	return;
	preorder(node->leftNode);
	printf("%c", node->data);
	preorder(node->rightNode);
}
```
```
//后序遍历
void inorder(TreeNode* node) {
	if (node == NULL)	return;
	preorder(node->leftNode);
	preorder(node->rightNode);
	printf("%c", node->data);
}
```

```
//层序遍历
//通过队列实现，将根节点出队，与此同时入队根的左右节点
void levelorder(TreeNode* node) {
	//TreeNode queue[1000];//结构体数组
	TreeNode* queue[1000];//指针数组
	int front = 0, rear = 0;

	//根节点入队
	queue[rear++] = node;

	//进入循环中，当队列为空时，结束循环(队列不为空，不结束循环)
	while (rear > front) {
		//出队
		TreeNode* node = queue[front++];
		printf("%c", node->data);
		//如果不为空，入队他的左右节点，
		if (node->leftNode != NULL) {
			queue[rear++] = node->leftNode;
		}
		if (node->rightNode != NULL) {
			queue[rear++] = node->rightNode;
		}
	}
}
```

#### 1.2.3.3 二叉树的计算类操作

二叉树的计算类操作，如：计算二叉树的节点总数，二叉树的叶子节点，二叉树的高度。

```
//统计二叉树的总结点
//如果节点不为空，则加一
int countNodes(TreeNode* root) {
	if (root == NULL) return 0;
	return 1 + countNodes(root->leftNode) + countNodes(root->rightNode);
}
```
```
//统计叶子节点
int countLeaves(TreeNode* root) {
	if (root == NULL) return 0;
	if (root->leftNode == NULL && root->rightNode == NULL)	return 1;
	return countLeaves(root->leftNode) + countLeaves(root->rightNode);
}
```
```
//统计树的高度
//算法构造，由树的递归定义，我们可以知道，当前节点的高度等于max(leftNode,rightNode)+1，有了递归关系式，我们便可以写出程序
int heightNode(TreeNode* node) {
	if (node == NULL) return 0;
	int left = heightNode(node->leftNode);
	int right = heightNode(node->rightNode);
	return (left > right ? left : right) + 1;
}
```

#### 1.2.3.4 二叉树的删除操作

```
//二叉树的删除操作，采用后序遍历的思想
void destroy(TreeNode* root) {
	if (root == NULL) return;
	destroy(root->leftNode);
	destroy(root->rightNode);
	free(root);
}
```

### 1.2.4 二叉树的应用

二叉树在很多方面都有着重要的应用，例如：二叉搜索树，满二叉树，哈夫曼树，平衡二叉树等等......
在下面的内容中，我将主要讲讲二叉树的几个重要变形。

## 1.3 二叉排序树

### 1.3.1 二叉排序树的基本概念

二叉排序树又称为二叉查找树，它具有以下性质：
对于任意一个节点：
- 若左子树不为空，则左子树上的所有节点的值都小于根节点；
- 若右子树不为空，则右子树上所有节点的值都大于根节点；
- 左右子树也分别是二叉排序树

它还有以下特性：其中序遍历BST的结果是一个升序序列。

### 1.3.2 二叉排序树的基本操作

- 二叉排序树的构造(插入)
- 二叉排序树的查找
- 二叉排序树的删除

#### 1.3.2.1 二叉排序树的查找

思想：如果待查找的目标小于该节点值，则去左子树，反之。如果查找到正确的值，直接返回，如果没查到，返回NULL；

```
TreeNode* search(TreeNode* root,int x) {
	if (root == NULL || root->data == x) return root;
	if (root->data < x) 
		return search(root->right,x);
	else
		return search(root->left, x);
}
```

#### 1.3.2.2 二叉排序树的创建(插入)

思想：查找失败的位置即为插入的位置(注意，递归时必须用一个值“接住”递归的返回值，否则返回的不是完整的树)

```
TreeNode* insert(TreeNode* root, int x) {
	if (root == NULL) {
		TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
		node->data = x;
		node->left = NULL;
		node->right = NULL;
		return node;
	}
	if (root->data < x)
		root->right = insert(root->right, x);
	else if(root->data > x)
		root->left = insert(root->left, x);
	//相等的情况不插入
	return root;
}
```

#### 1.3.2.3 二叉排序树的删除

二叉排序树的删除分为三种情况

1. 当此节点无子树时，直接删除。
2. 当子节点只有一个子树时，直接将该子树接在他的节点上。
3. 当此节点有两个子树时，将其中序前驱或中序后继代替此节点，然后删除。

## 1.4 满二叉树和完全二叉树

### 1.4.1 满二叉树

#### 1.4.1.1 满二叉树的定义

满二叉树：在一颗二叉树中，如果所有非叶子节点都有两个儿子节点，并且所有的叶子节点都在同一层，那么我们称他为满二叉树。

#### 1.4.1.2 满二叉树的性质

|性质         |说明
|:---:|:---|
|节点总数|若深度为k，则节点总是 n = 2^k - 1
|第i层的节点数|第i层的节点数为 n = 2^(i-1)
|叶子节点数|n = 2^(k-1)
|非叶子节点数|叶子节点数减一

### 1.4.2 完全二叉树

#### 1.4.2.1 完全二叉树的定义

完全二叉树：如果一个k层的二叉树，如果它的前k-1层都是满的，而k层的节点都是从左到右依次排列，中间没有缺口，那么我们说他是完全二叉树。

#### 1.4.2.2 完全二叉树的性质

|性质|说明
|:---:|:---|
|节点编号规律|从上到下，从左到右编号规律依次为1，2，3...
|对于任意节点i|左孩子编号2i，右孩子编号2i+1，其父节点编号i/2(取整)
|若有n个节点|则其深度为k = ⌊log₂n⌋ + 1

## 1.5 线索二叉树

### 1.5.1 定义

线索二叉树：线索二叉树是在二叉树的空指针位置存放线索，指向该节点在某种遍历顺序下的前驱或后继指针，而且用额外的标记位标识该指针是子指针还是线索指针。

```
struct Node{
	datatype date;
	struct Node* left;
	struct Node* right;
	int ltag;
	int rtag;
}
```

### 1.5.2 分类

- 按线索方向
	- 单线索指针
	- 双线索指针
- 按遍历顺序
	- 中序遍历(最常用)
	- 先序遍历
	- 后序遍历

### 1.5.3 性质

1. 线索用在原来为NULL的指针位置上，线索不会改变节点间的父子关系
2. 中序线索化后，对于任意节点p：
	- 若p->ltag为1，则该指针指向他的中序前驱
	- 若p->rtag为1，则该指针指向他的中序后继
3. 中序线索树可以在O(1)的空间下完成遍历，不需要栈或递归。
4. 中序前驱或中序后继的查找可以在其有线索的情况下达到O(1)时间复杂度。

### 1.5.4 构造

### 1.5.5 遍历