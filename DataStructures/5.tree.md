# 树

## 1.1 树的基本概念

### 1.1.1 树是什么

树：树是一种分层的、非线性数据结构，由若干节点和节点之间的父子关系组成。

树的特点：每个节点有0个或多个子节点，有且只有一个根节点，每个节点恰有一个父节点。

### 1.1.2 树的基本术语与性质

- **节点**(node)：存储数据的单元。
- **根**(root)：没有父节点的节点。
- **叶子**(leaf)：没有子节点的节点。
- **度**(degree)：节点的子节点数位该节点的度。树的度为所有节点中度最大的那个度数。
- **深度**(depth)：该节点到根节点的边数为他的深度，树的深度指的是所有节点到根节点的最大深度。

## 1.2 二叉树

### 1.2.1 二叉树的基本概念

二叉树：二叉树是一种特殊的树，每个节点最多只有两个子节点，通常被称为左子树和右子树。

### 1.2.2 二叉树的存储结构

```
typedef struct TreeNode {
    int data;
    struct TreeNode* leftNode;
    struct TreeNode* rightNode;
} TreeNode;  
```

### 1.2.3 二叉树的基本操作 

- 建立：创建节点，构造整棵树。
- 访问：遍历。
- 查找：按值查找节点。
- 计算：求节点数，叶子树，深度。
- 修改：插入节点，删除节点。
- 销毁：删除整颗树。

#### 1.2.3.1 建立二叉树

要想更容易的理解建立二叉树，我们最好了解一下二叉树的递归定义，即**每一个二叉树是一个有限节点的集合，它或者是空集，或者是由一个根节点和两个互不相交的二叉树组成**。

思想，由树的递归定义决定，如果根节点存在，那么左右节点都可以看作一颗新的树。
```
    TreeNode* createTree() {
        char ch;
        scanf(" %c", &ch);//%c前加空格，为跳过空白字符串机制(空白字符串：为换行，空格，等字符).
        if (ch == '#') {//"#"为字符串常量，后面还有一个\0，'#'为字符常量。
            return NULL;
        }
        TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
        node->data = ch;
        node->leftNode = createTree();
        node->rightNode = createTree();
        return node;
    }
```

#### 1.2.3.2 二叉树的遍历

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

其中，前序、中序、后序的顺序指的是根所在的位置，使用递归的思想，而层序遍历则通过队列实现。
```
//前序遍历
void preorder(TreeNode* node) {
	if (node == NULL)	return;
	printf("%c", node->data);
	preorder(node->leftNode);
	preorder(node->rightNode);
}
```
```
//中序遍历
void inorder(TreeNode* node) {
	if (node == NULL)	return;
	preorder(node->leftNode);
	printf("%c", node->data);
	preorder(node->rightNode);
}
```
```
//后序遍历
void inorder(TreeNode* node) {
	if (node == NULL)	return;
	preorder(node->leftNode);
	preorder(node->rightNode);
	printf("%c", node->data);
}
```

```
//层序遍历
//通过队列实现，将根节点出队，与此同时入队根的左右节点
void levelorder(TreeNode* node) {
	//TreeNode queue[1000];//结构体数组
	TreeNode* queue[1000];//指针数组
	int front = 0, rear = 0;

	//根节点入队
	queue[rear++] = node;

	//进入循环中，当队列为空时，结束循环(队列不为空，不结束循环)
	while (rear > front) {
		//出队
		TreeNode* node = queue[front++];
		printf("%c", node->data);
		//如果不为空，入队他的左右节点，
		if (node->leftNode != NULL) {
			queue[rear++] = node->leftNode;
		}
		if (node->rightNode != NULL) {
			queue[rear++] = node->rightNode;
		}
	}
}
```

#### 1.2.3.3 二叉树的计算类操作

二叉树的计算类操作，如：计算二叉树的节点总数，二叉树的叶子节点，二叉树的高度。

```
//统计二叉树的总结点
//如果节点不为空，则加一
int countNodes(TreeNode* root) {
	if (root == NULL) return 0;
	return 1 + countNodes(root->leftNode) + countNodes(root->rightNode);
}
```
```
//统计叶子节点
int countLeaves(TreeNode* root) {
	if (root == NULL) return 0;
	if (root->leftNode == NULL && root->rightNode == NULL)	return 1;
	return countLeaves(root->leftNode) + countLeaves(root->rightNode);
}
```
```
//统计树的高度
//算法构造，由树的递归定义，我们可以知道，当前节点的高度等于max(leftNode,rightNode)+1，有了递归关系式，我们便可以写出程序
int heightNode(TreeNode* node) {
	if (node == NULL) return 0;
	int left = heightNode(node->leftNode);
	int right = heightNode(node->rightNode);
	return (left > right ? left : right) + 1;
}
```

#### 1.2.3.4 二叉树的删除操作

```
//二叉树的删除操作，采用后序遍历的思想
void destroy(TreeNode* root) {
	if (root == NULL) return;
	destroy(root->leftNode);
	destroy(root->rightNode);
	free(root);
}
```

### 1.2.4 二叉树的应用

二叉树在很多方面都有着重要的应用，例如：二叉搜索树，满二叉树，哈夫曼树，平衡二叉树等等......
在下面的内容中，我将主要讲讲二叉树的几个重要变形。

## 1.3 