# 栈

## 1.1 栈的定义和基本运算

栈（stack）：一种受限定的线性表，限定其插入和删除操作只能在表一端进行，其中允许进行操作的这一端叫做栈顶，另一端叫做栈底，栈中插入操作叫进栈或入栈，删除操作叫做出栈或退栈。

栈的特点：后进先出LIFO(Last In Fist Out)。

栈的基本运算：
- 初始化栈
- 判断栈是否为空
- 入栈
- 出栈
- 读取栈顶元素

## 1.2 顺序栈

顺序栈(Sequential Stack)是用数组来实现栈结构的一种方式

### 1.2.1 顺序栈的基本结构

```
#define MAX 1000

typedef struct {
    char data[MAX];  // 存放栈内数据
    int top;         // 栈顶指针
} Stack;
```

### 1.2.2 顺序栈的运算实现

**初始化栈**
```
void initStack(Stack* s) {
	s->top = -1;
}
```
**判断栈是否为空**

```
int isEmpty(Stack s) {
	if (s.top == -1) {
		return 1;
	}
	return 0;
}
```

**入栈**
```
int push(Stack* s, int x) {
	if (s->top == MAX - 1) {
		printf("栈满，入栈失败");
		return 0;
	}
	s->data[++s->top] = x;
	return 1;
}
```

**出栈**
```
int pop(Stack* s, int* x) {
	if (s->top == -1) {
		printf("栈空，出栈失败");
		return 0;
	}
	*x = s->data[s->top--];
	return 1;
}
```

**读取栈顶元素**
```
int getTop(Stack* s, int* x) {
	if (s->top == -1) {
		printf("栈空，读取失败");
		return 0;
	}
	*x = s->data[s->top];
	return 1;
}
```

## 1.3 链栈

链栈是通过链式存储结构实现的栈

### 链栈的基本结构

```
typedef struct node {
	struct node* next;
	int data;
}StackNode;
```

### 链栈的运算实现

**初始化栈**
```
void init(StackNode* top) {
	top->next = NULL;
}
```
**判断栈是否为空**

```
int isEmpty(StackNode* top) {
	if (top->next == NULL) {
		printf("栈为空\n");
		return 1;
	}
	printf("栈不为空\n");
	return 0;
}
```

**入栈**
```
void push(StackNode* top, int x) {
	StackNode* node = (StackNode*)malloc(sizeof(StackNode));
	node->data = x;
	node->next = top->next;
	top->next = node;
}
```

**出栈**
```
void pop(StackNode* top, int* x) {
	if (isEmpty(top)) {
		return;
	}
	StackNode* p = top->next;
	top->next = p->next;
	*x = p->data;
	free(p);
}
```

**读取栈顶元素**
```
void getTop(StackNode* top, int* x) {
	if (isEmpty(top)) {
		return;
	}
	*x = top->next->data;
}
```

## 1.4 栈的应用 

### 1.4.1 平衡符号

判断输入的符号，如(){}[]是否合法

平衡符号的思想：将输入左括号等入栈，然后对后续所输入的括号进行判断，如果可以与栈顶的括号匹配，则出栈，如果发生不能匹配的情况则说明匹配出错，当结束时，如果栈为空，则说明表达式合法，如果栈中还有剩余符号，则说明不合法。

代码位置: *Note/DataStructures/code/stack_BalanceSymbols*

平衡符号的应用：
- 编译器语法分析
- html的语法检验
- 计算式表达式的检验
  
### 1.4.2 中缀表达式转后缀表达式